# JC - Javascript Compute

Данный модуль обеспечивает возможность GPGPU OOP на мета-языке JC с последущей
трансляцией на различные платформы: OpenCL, CUDA, GLSL... Точнее, будет обеспечивать
когда если вдруг заработает.

----

*WIP-DISCLAIMER:* То, что описано в тексте ниже - это черновик спецификации JC.
Не гарантируется, что в любой конкретный момент *node-jc* будет следовать
спецификации или даже работать вообще. Данный червновик является предметом
активных изменений.

----


## Подключение и спецификация модулей

Из ноды подключение через `jc.require()` срабатывает по тем же правилам, что и `import`
внутри JC кода. В случае `jc.require()` возвращается объект со всеми классами, которые
удалось загрузить, в виде его ключей. Использование отдельной версии `require`
обоснованно удобством и личными предпочтениями автора с одной стороны, и нежеланием
использовать *[DEPRECATED]*`require.extensions` - с другой.

```
const jc = require('node-jc');
const {Class1, Class2} = jc.require('./classes');
```

Когда подключение происходит из JC кода, предполагается обязательное перечисление
импортируемых классов. Источник указывается как имя папки или файла. Для файла
расширение `.jc` можно опускать. Для папки загружены будут ВСЕ JC файлы, найденные
внутри, и все подпапки рекурсивно. Если импортируется путь `path` и ему неоднозначно
соответствуют и папка и файл, то приоритет отдаётся папке. Для загрузки файла в
такой ситуации следует указать его расширение, убирая таким образом неоднозначность.
Этим и объясняется отдача приоритета директории: ей нельзя добавить расширение для
разрешения неоднозначности. При импорте в JC коде следует перечислить один или
несколько импортируемых классов. Импорт перечисления и перечисление импортов
равнозначны, так как модули кэшируются по мере сборки. Для обеспечения читаемости
кода можно смело разбивать один большой импорт на много строк. Импорты в JC коде
обязаны располагаться выше любого описания классов.

```
//const {Class1, Class2} = jc.require('classes');
import Class1, Class2 from classes
```

В JC импорте не нужно указывать ковычки для пути. Всё начиная с первого значащего
символа после `from` трактуется как путь. Кроме того, нет необходимости указывать
для локальных путей точку, так как импортер будет искать файлы именно в
локальной папке.

Для того чтобы загрузить модуль из ближайшей папки *node_modules* следует указать
префикс `node:` в имени загружаемого модуля.

```
//const {Class1, Class2} = jc.require('node:classes');
import Class1, Class2 from node:classes
```

Кроме этого есть возможность указать одну или несколько папок с библиотеками, при
конфигурировании JC:

```
const jc = require('node-jc');
jc.libs('my-libs');
jc.libs('../their-libs');
```

Это позволит использовать префикс `libs:` для автоматического поиска указанного
модуля в пределах перечисленных директорий.

```
//const {Class1, Class2} = jc.require('libs:classes');
import Class1, Class2 from libs:classes
```

## Описание классов

Классы описываются в JC файле ниже импортов и такое описание представляет собой
имя класса, после которого возможно указание другого класса (через `extends`),
от которого данный наследуется, и затем описание класса в фигурных скобках.

```
MyClass {
	...
}

MySecondClass extends MyClass {
	...
}
```


### Свойства

Доступны 3 вида свойств: динамические, статические и внешние (тоже статические).

1. Динамические: (GPU) для каждого экземпляра класса это свойство имеет независимое
значение. Такие свойства могут использоваться как видео-буферы (VBO).
2. Статические: (GPU) общее значение для всех экземпляров, в основном имеет смысл
использовать в качестве констант для разного рода коэфициентов, или как способ
передачи информации с CPU.
3. Внешние: (CPU) любые JS значения. Не видны на стороне GPU кода, и также являются
статическими. Предназначены для использования внешними методами.

В объявлении GPU свойств обязательно указывать тип данных. Одна строка одно
свойство. Через запятую несколько свойств на одной строке - нельзя. В качестве
типов GPU свойств могут выступать `char`, `int`, `float` и JC классы/списки.

Все динамические атрибуты классов используют префикс `.` во всех проявлениях. В
том числе при объявлении. Тип для динамических свойств указывается после их имени,
через `:`. Тип может быть векторной структурой, для этого надо перечислить имена
вложений. Структурные типы полезны для использования в качестве единого
перемеженного (interleaved, если так понятнее) VBO буфера. Гарантируется, что в
памяти структурный тип будет представлен в том порядке, в котором были перечислены
его вложения. Ограничение (векторность) состоит в том, что все вложения имеют
один и тот же тип данных, указанный перед перечислением имён вложений.

```
MyClass {
	.x   : float
	.xyz : float3
	.rgb : float r, g, b
}
```


Статические атрибуты класса объявляются и используются также как динамические,
но без символа `.`. Ещё одно отличие в том, что для статических свойств
может быть задано значение сразу в описании, по умолчанию это 0. Перезадать
значение статического свойства можно только со стороны CPU. На GPU такие свойства
доступны локальному классу просто по имеени, а соседним классам - как свойство
класса, но не экземпляра.

```
MyClass {
	x   : float = 10
	xyz : float3
	rgb : float r, g, b
}
```

Внешние свойства - это обычные JS свойства, тоже статические, но недоступные GPU.
Они существуют для удобства организации CPU кода непосредственно внутри JC модуля.
При их объявлении используется символ `@`, за которым следует описание, полностью
состоящее из обычного JS.

```
MyClass {
	@hello : 'world'
	@rgb   : {r: 1, g: 0, b: 0}
}
```

Можно создавать свойства-алиасы: при этом дополнительная память не выделяется,
просто одно физическое свойство становится доступно под несколькими именами.
Такие свойства могут быть удобны при наследовании, когда в дочернем классе
смысловая нагрузка на свойство изменяется.

```
MyClass {
	
	.x      : float
	x1      : float
	@hello  : 'world'
	
	.x2     : .x
	x12     : x
	@hello2 : @hello
	
}
```


### Методы

Методы также подразделяются на динамичесике, статические и внешние.

1. Динамические: (GPU) для каждого экземпляра класса этот метод исполняется в
его контексте данных, обращаясь через префикс `.` к динамическим свойствам. Эти
методы могут быть вызваны только из других динамических методов или из статических
методов с использованием операции итерирования.
2. Статические: (GPU) могут быть вызваны из других статических методов и из
внешних JS методов.
3. Внешние: (CPU) любой JS код. Не видны на стороне GPU кода, и также являются
статическими. Предназначены для использования другими внешними методами и JS модулями.


Конструктор класса - особый динамический метод с именем `constructor`. Он вызывается
при использовании оператора `new` в GPU коде. Конструктор не должен возвращать
никаких значений.

```
MyClass {
	
	.x : int
	.y : int
	
	.constructor(x, y) {
		.x = x
		.y = y
	}
	
}
```

В целом методы описываются таким же образом, как и свойства, с разницей в том, что
в их определении присутствует код вместо указания типа. Для внешних методов
используется нотация свойств, потому как внешнему свойству может быть присвоена
функция в качестве JS значения.

```
MyClass {
	
	.f() {
		
	}
	
	f2() {
		
	}
	
	@hello : function() {
		
	}
	
}
```

В качестве параметров GPU методов также могут выступать имена JC классов, обрамлённые
в угловые скобки. Это означает, что в качестве аргумента может быть передан
указанный класс или любой его наследник. Во внешние методы, по понятным соображениям,
передать любой класс всегда можно как обычное JS значение.

Дабы подытожить логику взаимодействия методов и переменных между собой, можно
рассмотреть следующую таблицу:

|      | .x | .f() | x  | f()  | @x | @f() |
| ---- | -- | ---- | -- | ---- | -- | ---- |
| .f() | rw | call | r  | call | no | no   |
|  f() | i  | i    | r  | call | no | no   |
| @f() | i  | i    | rw | call | rw | call |

Здесь:
* rw - чтение и запись;
* r - только чтение;
* i - требуется операция итерирования;
* call - прямой вызов функции;
* no - не доступно.

Итого:
* GPU коду не доступны `@внешние` данные.
* Внешний код может запускать статические функции непосредственно.
* Динамические функции могут быть вызваны напрямую только из других динамических функций.
* Из статических функций динамические используются посредством операций итерирования.
* Динамические методы могут использовать статические, т.к. те не выходят за рамки
возможностей динамических.

Как и в случае со свойствами можно создавать синонимы функций.

Дочерним классам доступны все свойства родительских классов так, будто это их
собственные свойства. Если в дочернем классе переопределяется динамический метод,
то внутри него предыдущая версия метода доступна под именем `.super`. Статические
и внешние переопределённые методы класса-предка доступны по имени класса.


### Итерирование

Операция итерирования предназначена для запуска GPU прохода либо локального цикла
по некоторой коллекции элементов.

1. Выделенное итерирование класса: запускает кернел для итерирования класса.
Итератор может принимать два аргумента: `item` - первый перечисленный аргумент
- указывает на текущий итерируемый элемент. Второй аргумент - системный
номер-идентификатор обрабатываемого элемента. Цикл проходит всквозную все
объекты данного класса. Посещаются только созданные экземпляры.

```
MyClass[](item, idx) {
	item.method();
}
```

2. Выделенное итерирование числа: запускает кернел для итерирования промежутка.
Разница, по сравнению с итерированием класса, состоит в том, что можно указать
произвольное число итериаций. При этом принимается лишь один агрумент, т.к. не
указан класс, относительно которого осуществляется перебор. Однако здесь можно
воспользоваться операцией индексирования класса. Самое же очевидное применение -
для создания групп элемнтов через оператор `new`.

```
10000[](idx) {
	// MyClass[idx].method(); // you can, if you dare
	new Something();
}
```

3. Итерирование динамического списка: локальный цикл, проходит все элементы списка.

```
[list](item, idx) {
	
}
```

4. Локальное итерирование числа: аналог цикла for.

```
[10](idx) {
	
}
```


### Динамические списки

В качестве типа GPU свойства может быть указан как JC класс, так и список объектов
такого класса. Такой список динамический и позволяет вставку и удаление элементов.

```
MyClass {
	
	.friends : OtherClass[]
	
	.constructor(num) {
		[num]() {
			.friends << new OtherClass(num-1)
		}
	}
	
}
OtherClass {
	
	.friends : MyClass[]
	
	.constructor(num) {
		[num]() {
			.friends << new MyClass(num-1)
		}
	}
	
}
```

Операция `<<` используется для добавления в конец такого списка.

