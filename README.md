# JC - Javascript Compute


## Подключение и спецификация модулей

Из ноды подключение через `require()` срабатывает по тем же правилам, что и `import`
внутри JC кода. В случае `require()` возвращается объект со всеми классами, которые
удалось загрузить, в виде его ключей.

```
const {Class1, Class2} = require('./lib');
```

Когда подключение происходит из JC кода, предполагается обязательное перечисление
импортируемых классов. Источник указывается как имя папки или файла. Для файла
расширение `.jc` можно опускать. Для папки загружены будут ВСЕ JC файлы, найденные
внутри, и все подпапки рекурсивно. Если импортируется путь `path` и ему неоднозначно
соответствуют и папка и файл, то приоритет отдаётся папке. Для загрузки файла в
такой ситуации следует указать его расширение, убирая таким образом неоднозначность.
Этим и объясняется отдача приоритета директории: ей нельзя добавить расширение для
разрешения неоднозначности. При импорте в JC коде следует перечислить один или
несколько импортируемых символов. Импорт перечисления и перечисление импортов
равнозначны, так как модули кэшируются по мере сборки. Для обеспечения читаемости
кода можно смело разбивать один большой импорт на много строк. Импорты в JC коде
обязаны располагаться выше любого описания классов.

```
//const {Class1, Class2} = require('./lib');
import Class1, Class2 from lib
```

В JC импорте не нужно указывать ковычки для пути. Всё начиная с первого значащего
символа после `from` трактуется как путь. Кроме того, нет необходимости указывать
для локальных путей точку, так как импортер будет искать код и в `node_modules` и в
локальной папке. Однако в случае конфликта приоритет отдаётся папке `node_modules`.
Причина снова в том, что быстрее всего такой конфликт будет разрешить добавлением
точки в начало локального пути: `./lib`.


## Описание классов

Классы описываются ниже импортов и такое описание представляет собой имя класса,
после которого возможно указание другого класса (через `extends`), от которого
данный наследуется, и затем описание класса в фигурных скобках.

```
MyClass {
	...
}

MySecondClass extends MyClass {
	...
}
```


### Свойства

Доступны 3 вида свойств: динамические, статические и внешние.

1. Динамические: (GPU) для каждого экземпляра класса это свойство имеет независимое
значение. Такие свойства могут использоваться как видео-буферы (VBO).
2. Статические: (GPU) общее значение для всех экземпляров, в основном имеет смысл
использовать в качестве констант для разного рода коэфициентов, или как способ
передачи информации с CPU.
3. Внешние: (CPU) любые JS значения. Не видны на стороне GPU кода, и также являются
статическими. Предназначены для использования внешними методами.

В объявлении GPU свойств обязательно указывать тип данных. Одна строка одно
свойство. Через запятую несколько свойств на одной строке - нельзя. В качестве
типов GPU свойств могут выступать `char`, `int`, `float` и JC классы/списки.

Все динамические атрибуты классов используют префикс `.` во всех проявлениях. В
том числе при объявлении. Тип для динамических свойств указывается после их имени,
через `:`. Тип может быть простой структурой, для этого надо перечислить типы
вложений и их имена. Структурные типы полезны для использования в качестве единого
перемеженного (interleaved, если так понятнее) VBO буфера. Гарантируется, что в
памяти структурный тип будет представлен в том порядке, в котором были перечислены
его вложения.

```
MyClass {
	.x   : float
	.xyz : float3
	.rgb : float r, float g, float b
}
```


Статические атрибуты класса объявляются и используются также как динамические,
но без символа `.`. Ещё одно отличие в том, что для статических свойств
может быть задано значение сразу в описании, по умолчанию это 0. Перезадать
значение статического свойства можно только со стороны CPU. На GPU такие свойства
доступны локальному классу просто по имеени, а соседним классам - как свойство
класса, но не экземпляра.

```
MyClass {
	x   : float = 10
	xyz : float3
	rgb : float r, float g, float b
}
```

Внешние свойства - это простые JS свойства, которые существуют для удобства
организации CPU кода непосредственно внутри JC модуля. При их объявлении
используется символ `@`, за которым следует описание, полностью состоящее из
обычного JS, обрамлённое в символы ``.

```
MyClass {
	@hello : `'world'`
	@rgb   : `{r: 1, g: 0, b: 0}`
}
```

Можно создавать свойства-алиасы: при этом дополнительная память не выделяется,
просто одно физическое свойство становится доступно под несколькими именами.
Такие свойства могут быть удобны при наследовании, когда в дочернем классе
смысловая нагрузка на свойство изменяется.

```
MyClass {
	
	.x      : float
	x       : float
	@hello  : `'world'`
	
	.x2     : .x
	x2      : x
	@hello2 : @hello
	
}
```


### Методы

Методы также подразделяются на динамичесике, статические и внешние.

1. Динамические: (GPU) для каждого экземпляра класса этот метод исполняется в
его контексте данных, обращаясь через префикс `.` к динамическим свойствам. Эти
методы могут быть вызваны только из других динамических методов или из статических
методов с использованием операции итерирования.
2. Статические: (GPU) могут быть вызваны из других статических методов и из
внешних JS методов.
3. Внешние: (CPU) любой JS код. Не видны на стороне GPU кода, и также являются
статическими. Предназначены для использования другими внешними методами и модулями.


Конструктор класса - особый динамический метод с именем `constructor`. Он вызывается
при использовании оператора `new` в GPU коде. Конструктор не должен возвращать
никаких значений.

```
MyClass {
	
	.x : int
	.y : int
	
	.constructor(x, y) {
		.x = x
		.y = y
	}
	
}
```

В целом методы описываются таким же образом, как и свойства, с разницей в том, что
в их определении присутствует код после указания типа. Для динамических методов
в качестве типа функции структуры не используются. Для внешних методов в принципе
используется нотация свойств, потому как внешнему свойству может быть присвоена
функция в качестве значения.

```
MyClass {
	
	.f : float () {
		
	}
	
	float f : () {
		
	}
	
	@hello : `function() {
		
	}`
	
}
```

В качестве параметров GPU методов также могут выступать имена JC классов, обрамлённые
в угловые скобки. Это означает, что в качестве аргумента может быть передан
указанный класс или любой его наследник. Во внешние методы, по понятным соображениям,
передать любой класс всегда можно как обычное JS значение.

Дабы подытожить логику взаимодействия методов и переменных между собой, можно
рассмотреть следующую таблицу:

|      | .x | .f() | x  | f()  | @x | @f() |
| ---- | -- | ---- | -- | ---- | -- | ---- |
| .f() | rw | call | r  | call | no | no   |
|  f() | i  | i    | r  | call | no | no   |
| @f() | i  | i    | rw | call | rw | call |

Здесь:
* rw - чтение и запись;
* r - только чтение;
* i - требуется операция итерирования;
* call - прямой вызов функции;
* no - не доступно.

Итого:
* GPU коду не доступны `@внешние` данные.
* Внешний код может запускать статические функции непосредственно.
* Динамические функции могут быть вызваны напрямую только из других динамических функций.
* Из статических функций динамические используются посредством операций итерирования.
* Динамические методы могут использовать статические, т.к. те не выходят за рамки
возможностей динамических.

Как и в случае со свойствами можно создавать синонимы функций.

Дочерним классам доступны все свойства родительских классов так, будто это их
собственные свойства. Если в дочернем классе переопределяется динамический метод,
то внутри него предыдущая версия метода доступна под именем `.super`. Статические
и внешние переопределённые методы класса-предка доступны по имени класса.


### Итерирование

Операция итерирования предназначена для запуска GPU прохода либо локального цикла
по некоторой коллекции элементов.

1. Итерирование класса: используется выделенный GPU цикл, `.` указывает на текущий
итерируемый элемент. Цикл проходит всквозную все объекты данного класса. Посещаются
только выделенные экземпляры.

```
MyClass[](item, idx) {
	
}
```

2. Выделенное итерирование числа: запускает кернел для итерирования промежутка.

```
10000[](idx) {
	
}
```

3. Итерирование динамического списка: локальный цикл, проходит все элементы списка.

```
[list](item, idx) {
	
}
```

4. Локальное итерирование числа: аналог цикла for.

```
[10](idx) {
	
}
```


### Динамические списки

В качестве типа GPU свойства может быть указан как JC класс, так и список объектов
такого класса. Такой список динамический и позволяет вставку и удаление элементов.

```
MyClass {
	
	.friends : OtherClass[]
	
	.constructor(num) {
		[num]() {
			.friends << new OtherClass(num-1)
		}
	}
	
}
OtherClass {
	
	.friends : MyClass[]
	
	.constructor(num) {
		[num]() {
			.friends << new MyClass(num-1)
		}
	}
	
}
```

Операция `<<` используется для добавления в конец такого списка.

